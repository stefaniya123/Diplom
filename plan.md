1. Перечень автоматизируемых сценариев

Будут автоматизированы следующие основные сценарии, покрывающие ключевые пути использования формы оплаты:

Успешная оплата картой (Покупка)
Открыть страницу /.
Нажать кнопку "Купить".
Заполнить форму оплаты:
Номер карты: 4444 4444 4444 4441
Месяц: 08
Год: 26
CVC/CVV: 999
Нажать кнопку "Продолжить".
Убедиться, что отображается уведомление об успешной операции ("Успешно. Операция одобрена Банком.").
Отказ в оплате картой (Покупка)
Открыть страницу /.
Нажать кнопку "Купить".
Заполнить форму оплаты:
Номер карты: 4444 4444 4444 4442
Месяц: 08
Год: 26
CVC/CVV: 999
Нажать кнопку "Продолжить".
Убедиться, что отображается уведомление об отказе в операции ("Отправляем запрос в банк...").
Успешная оплата картой (Покупка в кредит)
Открыть страницу /.
Нажать кнопку "Купить в кредит".
Заполнить форму оплаты:
Номер карты: 4444 4444 4444 4441
Месяц: 08
Год: 26
CVC/CVV: 999
Нажать кнопку "Продолжить".
Убедиться, что отображается уведомление об успешной операции ("Успешно. Операция одобрена Банком.").
Отказ в оплате картой (Покупка в кредит)
Открыть страницу /.
Нажать кнопку "Купить в кредит".
Заполнить форму оплаты:
Номер карты: 4444 4444 4444 4442
Месяц: 08
Год: 26
CVC/CVV: 999
Нажать кнопку "Продолжить".
Убедиться, что отображается уведомление об отказе в операции ("Отправляем запрос в банк...").
Примечание: Сценарии 1 и 3, а также 2 и 4 идентичны по действиям, но различаются начальной точкой входа (кнопка "Купить" или "Купить в кредит"). Это необходимо для проверки корректности работы обоих пользовательских путей.

2. Перечень используемых инструментов с обоснованием выбора
Для автоматизации будет использоваться следующий стек инструментов:

Язык программирования: Python
Обоснование: Python является одним из самых популярных языков для написания автотестов благодаря своей простоте, читаемости и огромному количеству библиотек. Он хорошо подходит для быстрого прототипирования и разработки надежных тестовых фреймворков. 
Фреймворк для UI-тестирования: Selenium WebDriver
Обоснование: Selenium — это стандарт де-факто для автоматизации веб-браузеров. Он поддерживает множество языков программирования и браузеров. Хотя он может быть сложнее в настройке и требовать больше ручного управления ожиданиями по сравнению с современными фреймворками, он имеет огромное сообщество, обширную документацию и является наиболее универсальным и проверенным временем решением. Его использование является обязательным требованием.
Система управления тестами и отчетностью: pytest
Обоснование: Pytest — это стандартный и мощный фреймворк для запуска тестов на Python. Он предоставляет удобную систему маркировок, параметризации тестов, гибкие механизмы фикстур и генерирует подробные отчеты. Легко интегрируется с Selenium и другими инструментами.
Инструмент для работы с базой данных: mysql-connector-python
Обоснование: Поскольку в приложении используется MySQL, для проверки состояния базы данных после выполнения операций (например, записи транзакции) будет использован официальный драйвер mysql-connector-python. Он обеспечивает прямое и надежное соединение с БД из Python-кода.
Контейнеризация: Docker
Обоснование: Так как приложение разворачивается через Docker, для создания воспроизводимой среды тестирования будет использован docker-compose. Это позволит запускать приложение и его зависимости (включая БД) в изолированных контейнерах перед каждым прогоном тестов, что гарантирует консистентность результатов.
3. Перечень и описание возможных рисков при автоматизации
Риск 1: Изменения в UI/UX приложения
Описание: Разработчики могут изменить структуру HTML, классы, идентификаторы или текстовые метки элементов (кнопок, полей ввода). Это приведет к падению автотестов, так как они не смогут найти нужные элементы.
Митигация: Использовать уникальные и стабильные селекторы (например, data-testid или aria-label). Регулярно обновлять тесты при изменениях в интерфейсе. Внедрить практику Code Review для изменений в UI.
Риск 2: Проблемы с синхронизацией (Flaky Tests)
Описание: Тесты могут падать из-за временных задержек в загрузке страницы, анимаций или ответов сервера. Например, тест может попытаться кликнуть на кнопку до того, как она станет кликабельной.
Митигация: Активно использовать явные ожидания (WebDriverWait) в Selenium для ожидания появления, видимости или кликабельности элементов. Избегать жестких time.sleep().
Риск 3: Зависимость от внешнего сервиса (Банк)
Описание: Приложение отправляет запрос в банк. В реальном мире этот сервис может быть недоступен, медленным или возвращать непредсказуемые ответы, что сломает тесты.
Митигация: Вместо обращения к реальному банку, использовать мокирование (mocking) или заглушку (stub) для эмуляции ответов банка. Для этого можно использовать библиотеку responses или pytest-httpserver для перехвата HTTP-запросов к банковскому API и возврата предопределенных ответов (например, из файла gate-simulator/data.json).
Риск 4: Проблемы с окружением (Docker)
Описание: Сборка или запуск контейнеров может завершиться с ошибкой из-за конфликтов портов, нехватки ресурсов или проблем с конфигурацией docker-compose.yml.
Митигация: Тщательно протестировать скрипты запуска окружения. Добавить логирование и обработку ошибок в скрипты. Использовать команды docker-compose down --volumes для очистки перед запуском.