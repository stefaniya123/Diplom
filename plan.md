# План автоматизации тестирования формы оплаты

## 1. Перечень автоматизируемых сценариев

Будут автоматизированы следующие основные сценарии, покрывающие ключевые пути использования формы оплаты:

### Сценарий 1: Успешная оплата картой (Покупка)
- Открыть страницу `/`.
- Нажать кнопку **"Купить"**.
- Заполнить форму оплаты:
  - Номер карты: `4444 4444 4444 4441` *(карта со статусом APPROVED)*
  - Месяц: `08`
  - Год: `26`
  - Владелец: `иван`
  - CVC/CVV: `999`
- Нажать кнопку **"Продолжить"**.
- Убедиться, что отображается уведомление об успешной операции:  
  **"Успешно. Операция одобрена Банком."**
- **Дополнительно (проверка БД)**: Убедиться, что в таблице `payment_entity` создана запись:
  - `amount = 4500000` (в копейках)
  - `status = "APPROVED"`
  - `transaction_id` не пуст

### Сценарий 2: Успешная оплата картой (Покупка в кредит)
- Открыть страницу `/`.
- Нажать кнопку **"Купить в кредит"**.
- Заполнить форму оплаты:
  - Номер карты: `4444 4444 4444 4441` *(карта со статусом APPROVED)*
  - Месяц: `08`
  - Год: `26`
  - Владелец: `иван`
  - CVC/CVV: `999`
- Нажать кнопку **"Продолжить"**.
- Убедиться, что отображается уведомление об успешной операции:  
  **"Успешно. Операция одобрена Банком."**
- **Дополнительно (проверка БД)**: Убедиться, что в таблице `credit_request_entity` создана запись:
  - `status = "APPROVED"`
  - `transaction_id` не пуст

### Сценарий 3: Отклонённая оплата картой (Покупка) — **БАГ**
- Открыть страницу `/`.
- Нажать кнопку **"Купить"**.
- Заполнить форму оплаты:
  - Номер карты: `4444 4444 4444 4442` *(карта со статусом DECLINED)*
  - Месяц: `08`
  - Год: `26`
  - Владелец: `иван`
  - CVC/CVV: `999`
- Нажать кнопку **"Продолжить"**.
- **Фактическое поведение (БАГ)**: Отображается уведомление об **успешной** операции:  
  **"Успешно. Операция одобрена Банком."**
- **Ожидаемое поведение**: Должно отображаться **уведомление об ошибке**:  
  **"Ошибка! Банк отказал в проведении операции."**
- **Проверка БД**: Убедиться, что в таблице `payment_entity` создана запись:
  - `amount = 4500000`
  - `status = "DECLINED"` ← **Корректно!**
  - `transaction_id` не пуст
- **Вывод**: Налицо **несоответствие между UI и БД** — критический баг.

### Сценарий 4: Отклонённая оплата картой (Покупка в кредит) — **БАГ**
- Открыть страницу `/`.
- Нажать кнопку **"Купить в кредит"**.
- Заполнить форму оплаты:
  - Номер карты: `4444 4444 4444 4442` *(карта со статусом DECLINED)*
  - Месяц: `08`
  - Год: `26`
  - Владелец: `иван`
  - CVC/CVV: `999`
- Нажать кнопку **"Продолжить"**.
- **Фактическое поведение (БАГ)**: Отображается уведомление об **успешной** операции:  
  **"Успешно. Операция одобрена Банком."**
- **Ожидаемое поведение**: Должно отображаться **уведомление об ошибке**:  
  **"Ошибка! Банк отказал в проведении операции."**
- **Проверка БД**: Убедиться, что в таблице `credit_request_entity` создана запись:
  - `status = "DECLINED"` ← **Корректно!**
  - `transaction_id` не пуст
- **Вывод**: Налицо **несоответствие между UI и БД** — критический баг.

### Сценарий 5: Валидация пустых полей (Покупка)
- Открыть страницу `/`.
- Нажать кнопку **"Купить"**.
- **Не заполнять** поля формы.
- Нажать кнопку **"Продолжить"**.
- Убедиться, что под каждым полем отображаются сообщения об ошибках:
  - Номер карты: **"Неверный формат"**
  - Месяц: **"Неверный формат"**
  - Год: **"Неверный формат"**
  - Владелец: **"Поле обязательно для заполнения"**
  - CVC: **"Неверный формат"**

### Сценарий 6: Валидация пустых полей (Покупка в кредит)
- Открыть страницу `/`.
- Нажать кнопку **"Купить в кредит"**.
- **Не заполнять** поля формы.
- Нажать кнопку **"Продолжить"**.
- Убедиться, что под каждым полем отображаются те же сообщения об ошибках, что и в Сценарии 5.

### Сценарий 7: Валидация истекшего срока действия карты (Покупка)
- Открыть страницу `/`.
- Нажать кнопку **"Купить"**.
- Заполнить форму:
  - Номер карты: `4444 4444 4444 4442`
  - Месяц: `10`
  - **Год: `24`** (истекший)
  - Владелец: `иван`
  - CVC: `999`
- Нажать кнопку **"Продолжить"**.
- Убедиться, что под полем **"Год"** отображается ошибка:  
  **"Истёк срок действия карты"**.

### Сценарий 8: Валидация истекшего срока действия карты (Покупка в кредит)
- Открыть страницу `/`.
- Нажать кнопку **"Купить в кредит"**.
- Заполнить форму с **годом `24`**.
- Нажать кнопку **"Продолжить"**.
- Убедиться, что под полем **"Год"** отображается ошибка:  
  **"Истёк срок действия карты"**.

### Сценарий 9: Выявление бага — некорректная ошибка при вводе будущей даты (11/25) (Покупка)
- Открыть страницу `/`.
- Нажать кнопку **"Купить"**.
- Заполнить форму:
  - Месяц: `11`
  - **Год: `25`** (корректная будущая дата)
- Нажать кнопку **"Продолжить"**.
- **Ожидаемое поведение**: отсутствие ошибки **ИЛИ** ошибка **"Истёк срок действия карты"** под полем "Год" (если дата истекла).
- **Фактическое поведение (баг)**: появляется ошибка **"Неверно указан срок действия карты"** под полем **"Месяц"**.
- **Цель теста**: автоматически **фиксирует наличие бага**, падая при его воспроизведении.

### Сценарий 10: Выявление бага — некорректная ошибка при вводе будущей даты (11/25) (Покупка в кредит)
- Аналогично Сценарию 9, но начиная с кнопки **"Купить в кредит"**.
- Цель: убедиться, что баг воспроизводится в обоих платежных сценариях.

> **Примечание**: Сценарии 1 и 2, 3 и 4, 5 и 6, 7 и 8, 9 и 10 идентичны по действиям, но различаются начальной точкой входа (кнопка **"Купить"** или **"Купить в кредит"**). Это необходимо для проверки корректности работы обоих пользовательских путей.

---

## 2. Перечень используемых инструментов с обоснованием выбора

Для автоматизации будет использоваться следующий стек инструментов:

### Язык программирования: Python
**Обоснование**: Python является одним из самых популярных языков для написания автотестов благодаря своей простоте, читаемости и огромному количеству библиотек. Он хорошо подходит для быстрого прототипирования и разработки надежных тестовых фреймворков.

### Фреймворк для UI-тестирования: Selenium WebDriver
**Обоснование**: Selenium — это стандарт де-факто для автоматизации веб-браузеров. Он поддерживает множество языков программирования и браузеров. Хотя он может быть сложнее в настройке и требовать больше ручного управления ожиданиями по сравнению с современными фреймворками, он имеет огромное сообщество, обширную документацию и является наиболее универсальным и проверенным временем решением. Его использование является обязательным требованием.

### Система управления тестами и отчетностью: pytest
**Обоснование**: Pytest — это стандартный и мощный фреймворк для запуска тестов на Python. Он предоставляет удобную систему маркировок, параметризации тестов, гибкие механизмы фикстур и генерирует подробные отчеты. Легко интегрируется с Selenium и другими инструментами.

### Инструмент для работы с базой данных: mysql-connector-python
**Обоснование**: Поскольку в приложении используется MySQL, для проверки состояния базы данных после выполнения операций (например, записи транзакции) будет использован официальный драйвер `mysql-connector-python`. Он обеспечивает прямое и надежное соединение с БД из Python-кода.

### Контейнеризация: Docker
**Обоснование**: Так как приложение разворачивается через Docker, для создания воспроизводимой среды тестирования будет использован `docker-compose`. Это позволит запускать приложение и его зависимости (включая БД) в изолированных контейнерах перед каждым прогоном тестов, что гарантирует консистентность результатов.

> **Дополнение**: Для тестов, проверяющих данные в БД, используется **явное очищение таблиц** (`payment_entity`, `credit_request_entity`) перед каждым тестом для обеспечения изоляции и предсказуемости.

---

## 3. Перечень и описание возможных рисков при автоматизации

### Риск 1: Изменения в UI/UX приложения
**Описание**: Разработчики могут изменить структуру HTML, классы, идентификаторы или текстовые метки элементов (кнопок, полей ввода). Это приведет к падению автотестов, так как они не смогут найти нужные элементы.  
**Митигация**: Использовать уникальные и стабильные селекторы (например, `data-testid` или `aria-label`). Регулярно обновлять тесты при изменениях в интерфейсе. Внедрить практику Code Review для изменений в UI.

### Риск 2: Проблемы с синхронизацией (Flaky Tests)
**Описание**: Тесты могут падать из-за временных задержек в загрузке страницы, анимаций или ответов сервера. Например, тест может попытаться кликнуть на кнопку до того, как она станет кликабельной.  
**Митигация**: Активно использовать явные ожидания (`WebDriverWait`) в Selenium для ожидания появления, видимости или кликабельности элементов. Избегать жестких `time.sleep()`.

### Риск 3: Зависимость от внешнего сервиса (Банк)
**Описание**: Приложение отправляет запрос в банк. В реальном мире этот сервис может быть недоступен, медленным или возвращать непредсказуемые ответы, что сломает тесты.  
**Митигация**: Вместо обращения к реальному банку, использовать мокирование (mocking) или заглушку (stub) для эмуляции ответов банка. Для этого можно использовать библиотеку `responses` или `pytest-httpserver` для перехвата HTTP-запросов к банковскому API и возврата предопределенных ответов (например, из файла `gate-simulator/data.json`).

### Риск 4: Проблемы с окружением (Docker)
**Описание**: Сборка или запуск контейнеров может завершиться с ошибкой из-за конфликтов портов, нехватки ресурсов или проблем с конфигурацией `docker-compose.yml`.  
**Митигация**: Тщательно протестировать скрипты запуска окружения. Добавить логирование и обработку ошибок в скрипты. Использовать команды `docker-compose down --volumes` для очистки перед запуском.

### Риск 5: Несоответствие между UI и БД
**Описание**: Приложение может показывать пользователю один результат (успех), в то время как в БД фиксируется другой (отказ). Это приводит к созданию **ложноположительных или ложноотрицательных тестов**, если тестирование ведётся только по UI.  
**Митигация**: **Обязательная проверка состояния базы данных** после выполнения каждой транзакции. UI-тесты должны дополняться **тестами на уровне БД**, чтобы гарантировать согласованность данных и бизнес-логики.